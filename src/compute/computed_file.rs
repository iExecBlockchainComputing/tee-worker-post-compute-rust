use crate::compute::errors::ReplicateStatusCause;
use crate::compute::signer::sign_enclave_challenge;
use crate::compute::utils::env_utils::{get_env_var_or_error, TeeSessionEnvironmentVariable};
use crate::compute::utils::hash_utils::concatenate_and_hash;
use crate::compute::utils::result_utils::{compute_web2_result_digest, compute_web3_result_digest};
use log::{error, info};
use serde::{Deserialize, Serialize};
use std::{fs, path::Path};

/// Represents the structure of a computed.json file generated by iExec tasks.
///
/// This struct contains all the necessary information about a completed computation task,
/// including output paths, callback data, task identification, and result verification data.
/// The fields are serialized/deserialized using camelCase naming convention to match
/// the expected JSON format.
///
/// # Example
///
/// ```json
/// {
///   "deterministic-output-path": "/iexec_out/result.txt",
///   "callback-data": "0xabc123...",
///   "task-id": "0x123456789abcdef",
///   "result-digest": "0x789abc...",
///   "enclave-signature": "0xdef456...",
///   "error-message": null
/// }
/// ```
#[derive(Debug, Default, Serialize, Deserialize)]
#[serde(rename_all(deserialize = "kebab-case"))]
pub struct ComputedFile {
    pub deterministic_output_path: Option<String>,
    pub callback_data: Option<String>,
    pub task_id: Option<String>,
    pub result_digest: Option<String>,
    pub enclave_signature: Option<String>,
    pub error_message: Option<String>,
}

/// Reads and parses a computed.json file from the specified directory.
///
/// This function locates the computed.json file in the given directory, reads its contents,
/// and deserializes it into a [`ComputedFile`] struct. The task ID is automatically set
/// in the resulting struct instance.
///
/// # Arguments
///
/// * `chain_task_id` - The blockchain task identifier to associate with this computed file
/// * `computed_file_dir` - The directory path where the computed.json file is located
///
/// # Returns
///
/// * `Ok(ComputedFile)` - Successfully parsed computed file with task ID set
/// * `Err(ReplicateStatusCause)` - Error if file cannot be read or parsed
///
/// # Errors
///
/// This function will return an error in the following situations:
/// * `chain_task_id` is empty (returns `PostComputeComputedFileNotFound`)
/// * `computed_file_dir` is empty (returns `PostComputeComputedFileNotFound`)
/// * The computed.json file does not exist in the specified directory (returns `PostComputeComputedFileNotFound`)
/// * The file cannot be read due to permissions or I/O errors (returns `PostComputeComputedFileNotFound`)
/// * The JSON content is invalid or cannot be deserialized (returns `PostComputeComputedFileNotFound`)
///
/// # Example
///
/// ```
/// use crate::compute::computed_file::read_computed_file;
///
/// match read_computed_file("0x123456789abcdef", "/iexec_out") {
///     Ok(computed_file) => {
///         println!("Task ID: {:?}", computed_file.task_id);
///         println!("Output path: {:?}", computed_file.deterministic_output_path);
///     },
///     Err(e) => eprintln!("Error reading computed file: {:?}", e),
/// }
/// ```
pub fn read_computed_file(
    chain_task_id: &str,
    computed_file_dir: &str,
) -> Result<ComputedFile, ReplicateStatusCause> {
    info!("read_computed_file stage started");
    if chain_task_id.is_empty() {
        error!(
            "Failed to read compute file (empty chain_task_id) [chain_task_id:{}, computed_file_dir:{}]",
            chain_task_id, computed_file_dir
        );
        return Err(ReplicateStatusCause::PostComputeComputedFileNotFound);
    }

    if computed_file_dir.is_empty() {
        error!(
            "Failed to read compute file (empty computed_file_dir) [chain_task_id:{}, computed_file_dir:{}]",
            chain_task_id, computed_file_dir
        );
        return Err(ReplicateStatusCause::PostComputeComputedFileNotFound);
    }

    let computed_file_path = Path::new(computed_file_dir).join("computed.json");
    let json_string = match fs::read_to_string(&computed_file_path) {
        Ok(content) => content,
        Err(e) => {
            error!(
                "Failed to read compute file [chain_task_id:{}, computed_file_dir:{}, error:{}]",
                chain_task_id, computed_file_dir, e
            );
            return Err(ReplicateStatusCause::PostComputeComputedFileNotFound);
        }
    };

    match serde_json::from_str::<ComputedFile>(&json_string) {
        Ok(mut computed_file) => {
            computed_file.task_id = Some(chain_task_id.to_string());
            info!("read_computed_file stage completed");
            Ok(computed_file)
        }
        Err(_) => {
            error!(
                "Failed to read compute file [chain_task_id:{}, computed_file_dir:{}]",
                chain_task_id, computed_file_dir
            );
            Err(ReplicateStatusCause::PostComputeComputedFileNotFound)
        }
    }
}

/// Computes and sets the result digest for a computed file based on the task type.
///
/// This function determines the appropriate digest computation method based on whether
/// the task is in callback mode (web3) or standard mode (web2), then computes and
/// stores the result digest in the provided [`ComputedFile`] instance.
///
/// The digest computation follows these rules:
/// - **Web3 mode** (callback): Uses keccak256 hash of the callback data
/// - **Web2 mode** (standard): Uses SHA256 hash of the output files/directory
///
/// # Arguments
///
/// * `computed_file` - A mutable reference to the [`ComputedFile`] instance to update
/// * `is_callback_mode` - Boolean indicating whether this is a web3 callback task
///
/// # Returns
///
/// * `Ok(())` - Successfully computed and set the result digest
/// * `Err(ReplicateStatusCause)` - Error if digest computation failed
///
/// # Errors
///
/// This function will return an error in the following situations:
/// * The result digest computation returns an empty string (returns `PostComputeResultDigestComputationFailed`)
/// * For web3 mode: callback data is missing or empty
/// * For web2 mode: deterministic output path is missing, empty, or points to non-existent files
///
/// # Example
///
/// ```
/// use crate::compute::computed_file::{build_result_digest_in_computed_file, ComputedFile};
///
/// let mut computed_file = ComputedFile {
///     task_id: Some("0x123".to_string()),
///     callback_data: Some("0xabc...".to_string()),
///     deterministic_output_path: None,
///     result_digest: None,
///     enclave_signature: None,
///     error_message: None,
/// };
///
/// // For a web3 callback task
/// match build_result_digest_in_computed_file(&mut computed_file, true) {
///     Ok(()) => println!("Result digest: {:?}", computed_file.result_digest),
///     Err(e) => eprintln!("Error computing digest: {:?}", e),
/// }
/// ```
pub fn build_result_digest_in_computed_file(
    computed_file: &mut ComputedFile,
    is_callback_mode: bool,
) -> Result<(), ReplicateStatusCause> {
    info!(
        "build_result_digest_in_computed_file stage started [mode:{}]",
        if is_callback_mode { "web3" } else { "web2" }
    );

    let result_digest = if is_callback_mode {
        compute_web3_result_digest(computed_file)
    } else {
        compute_web2_result_digest(computed_file)
    };

    if result_digest.is_empty() {
        return Err(ReplicateStatusCause::PostComputeResultDigestComputationFailed);
    }

    computed_file.result_digest = Some(result_digest.to_string());
    Ok(())
}

pub fn sign_computed_file(computed_file: &mut ComputedFile) -> Result<(), ReplicateStatusCause> {
    info!("Signer stage started");
    let worker_address: String = get_env_var_or_error(
        TeeSessionEnvironmentVariable::SignWorkerAddress,
        ReplicateStatusCause::PostComputeWorkerAddressMissing,
    )?;
    let task_id = computed_file.task_id.as_ref().unwrap();
    let result_digest = computed_file.result_digest.as_ref().unwrap();

    let result_hash = concatenate_and_hash(&[task_id, result_digest]);
    let result_seal = concatenate_and_hash(&[&worker_address, task_id, result_digest]);
    let message_hash = concatenate_and_hash(&[&result_hash, &result_seal]);

    let tee_challenge_private_key: String = get_env_var_or_error(
        TeeSessionEnvironmentVariable::SignTeeChallengePrivateKey,
        ReplicateStatusCause::PostComputeTeeChallengePrivateKeyMissing,
    )?;

    let enclave_signature = sign_enclave_challenge(&message_hash, &tee_challenge_private_key)?;

    computed_file.enclave_signature = Some(enclave_signature);
    info!("Signer stage completed");
    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::io::Write;
    use temp_env::with_vars;
    use tempfile::tempdir;

    const TEST_TASK_ID: &str = "0x123456789abcdef";

    // region read_computed_file
    #[test]
    fn read_computed_file_returns_computed_file_when_valid_input() {
        let dir = tempdir().unwrap();
        let dir_path = dir.path().to_str().unwrap();
        let file_path = dir.path().join("computed.json");

        let test_json =
            r#"{"deterministic-output-path":"/iexec_out/result.txt","callback-data":"0xabc"}"#;
        let mut file = fs::File::create(&file_path).unwrap();
        file.write_all(test_json.as_bytes()).unwrap();

        let result = read_computed_file(TEST_TASK_ID, dir_path);
        assert!(result.is_ok());

        let computed_file = result.unwrap();
        assert_eq!(computed_file.task_id, Some(TEST_TASK_ID.to_string()));
        assert_eq!(
            computed_file.deterministic_output_path,
            Some("/iexec_out/result.txt".to_string())
        );
        assert_eq!(computed_file.callback_data, Some("0xabc".to_string()));
    }

    #[test]
    fn read_computed_file_returns_error_when_chain_task_id_is_empty() {
        let result = read_computed_file("", "/tmp");

        assert!(result.is_err());
        assert_eq!(
            result.unwrap_err(),
            ReplicateStatusCause::PostComputeComputedFileNotFound
        );
    }

    #[test]
    fn read_computed_file_returns_error_when_computed_file_dir_is_empty() {
        let result = read_computed_file(TEST_TASK_ID, "");

        assert!(result.is_err());
        assert_eq!(
            result.unwrap_err(),
            ReplicateStatusCause::PostComputeComputedFileNotFound
        );
    }

    #[test]
    fn read_computed_file_returns_error_when_computed_json_is_missing() {
        let dir = tempdir().unwrap();
        let dir_path = dir.path().to_str().unwrap();

        let result = read_computed_file(TEST_TASK_ID, dir_path);

        assert!(result.is_err());
        assert_eq!(
            result.unwrap_err(),
            ReplicateStatusCause::PostComputeComputedFileNotFound
        );
    }

    #[test]
    fn read_computed_file_returns_error_when_computed_json_is_empty() {
        let dir = tempdir().unwrap();
        let file_path = dir.path().join("computed.json");

        let test_json = "";
        let mut file = fs::File::create(&file_path).unwrap();
        file.write_all(test_json.as_bytes()).unwrap();

        let result = read_computed_file(TEST_TASK_ID, dir.path().to_str().unwrap());

        assert!(result.is_err());
        assert_eq!(
            result.unwrap_err(),
            ReplicateStatusCause::PostComputeComputedFileNotFound
        );
    }

    #[test]
    fn read_computed_file_returns_error_when_computed_json_is_invalid() {
        let dir = tempdir().unwrap();
        let file_path = dir.path().join("computed.json");

        let test_json = r#"{"invalid-json":}"#;
        let mut file = fs::File::create(&file_path).unwrap();
        file.write_all(test_json.as_bytes()).unwrap();

        let result = read_computed_file(TEST_TASK_ID, dir.path().to_str().unwrap());

        assert!(result.is_err());
        assert_eq!(
            result.unwrap_err(),
            ReplicateStatusCause::PostComputeComputedFileNotFound
        );
    }
    // endregion

    // region build_result_digest_in_computed_file
    #[test]
    fn build_result_digest_in_computed_file_computes_web3_digest_when_is_callback_mode_is_true() {
        let mut computed_file = ComputedFile {
            task_id: Some(TEST_TASK_ID.to_string()),
            callback_data: Some(
                "0x0000000000000000000000000000000000000000000000000000000000000001".to_string(),
            ),
            ..Default::default()
        };

        let result = build_result_digest_in_computed_file(&mut computed_file, true);

        assert!(result.is_ok());
        assert_eq!(
            computed_file.result_digest,
            Some("0xcb371be217faa47dab94e0d0ff0840c6cbf41645f0dc1a6ae3f34447155a76f3".to_string())
        );
    }

    #[test]
    fn build_result_digest_in_computed_file_computes_web2_digest_when_is_callback_mode_is_false() {
        let dir = tempdir().unwrap();
        let output_dir = dir.path().join("output");
        fs::create_dir(&output_dir).unwrap();

        let test_file_path = output_dir.join("test.txt");
        let mut file = fs::File::create(&test_file_path).unwrap();
        file.write_all(b"test content").unwrap();

        let mut computed_file = ComputedFile {
            task_id: Some(TEST_TASK_ID.to_string()),
            deterministic_output_path: Some(output_dir.to_str().unwrap().to_string()),
            ..Default::default()
        };

        let result = build_result_digest_in_computed_file(&mut computed_file, false);

        assert!(result.is_ok());
        assert!(computed_file.result_digest.is_some());
    }

    #[test]
    fn build_result_digest_in_computed_file_returns_error_when_result_digest_is_empty() {
        let mut computed_file = ComputedFile {
            task_id: Some(TEST_TASK_ID.to_string()),
            deterministic_output_path: Some("/non_existent_path".to_string()),
            ..Default::default()
        };

        let result = build_result_digest_in_computed_file(&mut computed_file, false);

        assert!(result.is_err());
        assert_eq!(
            result.unwrap_err(),
            ReplicateStatusCause::PostComputeResultDigestComputationFailed
        );
    }
    // endregion

    // region sign_computed_file
    const TEST_WORKER_ADDRESS: &str = "0x1234567890abcdef1234567890abcdef12345678";
    const TEST_TEE_CHALLENGE_PRIVATE_KEY: &str =
        "0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80";
    const TEST_RESULT_DIGEST: &str =
        "0xcb371be217faa47dab94e0d0ff0840c6cbf41645f0dc1a6ae3f34447155a76f3";

    #[test]
    fn sign_computed_file_returns_signature_when_all_env_and_fields_present() {
        with_vars(
            vec![
                (
                    TeeSessionEnvironmentVariable::SignWorkerAddress.name(),
                    Some(TEST_WORKER_ADDRESS),
                ),
                (
                    TeeSessionEnvironmentVariable::SignTeeChallengePrivateKey.name(),
                    Some(TEST_TEE_CHALLENGE_PRIVATE_KEY),
                ),
            ],
            || {
                let mut computed_file = ComputedFile {
                    task_id: Some(TEST_TASK_ID.to_string()),
                    result_digest: Some(TEST_RESULT_DIGEST.to_string()),
                    ..Default::default()
                };

                let result = sign_computed_file(&mut computed_file);
                assert!(result.is_ok(), "Signing should be successful");
                assert!(
                    computed_file.enclave_signature.is_some(),
                    "Enclave signature should be Some"
                );
                assert!(
                    !computed_file.enclave_signature.as_ref().unwrap().is_empty(),
                    "Enclave signature should not be empty"
                );
            },
        );
    }

    #[test]
    fn sign_computed_file_returns_error_when_worker_address_missing() {
        with_vars(
            vec![(
                TeeSessionEnvironmentVariable::SignTeeChallengePrivateKey.name(),
                Some(TEST_TEE_CHALLENGE_PRIVATE_KEY),
            )],
            || {
                let mut computed_file = ComputedFile {
                    task_id: Some(TEST_TASK_ID.to_string()),
                    result_digest: Some(TEST_RESULT_DIGEST.to_string()),
                    ..Default::default()
                };

                let result = sign_computed_file(&mut computed_file);
                assert!(
                    matches!(
                        result,
                        Err(ReplicateStatusCause::PostComputeWorkerAddressMissing)
                    ),
                    "Should return PostComputeWorkerAddressMissing error"
                );
            },
        );
    }

    #[test]
    fn sign_computed_file_returns_error_when_tee_private_key_missing() {
        with_vars(
            vec![(
                TeeSessionEnvironmentVariable::SignWorkerAddress.name(),
                Some(TEST_WORKER_ADDRESS),
            )],
            || {
                let mut computed_file = ComputedFile {
                    task_id: Some(TEST_TASK_ID.to_string()),
                    result_digest: Some(TEST_RESULT_DIGEST.to_string()),
                    ..Default::default()
                };

                let result = sign_computed_file(&mut computed_file);
                assert!(
                    matches!(
                        result,
                        Err(ReplicateStatusCause::PostComputeTeeChallengePrivateKeyMissing)
                    ),
                    "Should return PostComputeTeeChallengePrivateKeyMissing error"
                );
            },
        );
    }
    // endregion
}
